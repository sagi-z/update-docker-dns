#!/bin/bash

# update-docker-dns is used to selectively expose docker containers by name.
# Copyright (c) 2018, Sagi Zeevi (www.theimpossiblecode.com).
# All rights reserved.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>

WAIT_EVENS_TO=10
ECHO="/bin/echo"

# Path to the addn-hosts file
CONTAINER_HOSTS=/etc/docker-container-hosts

DOMAIN_NAME=`domainname`
if [ `$ECHO  "$DOMAIN_NAME" | grep -v '\.'` ]; then
    DOMAIN_NAME=""
fi

generate_docker_hosts ()
{ 
    $ECHO "# Auto-generated by $0" > $CONTAINER_HOSTS
    for cid in `docker ps -q`; do
        use_docker_host=""
        host=""
        subdomain_hosts=""
        container_domain=""
        domain_is_host=""
        ip=""
        ips=""
        use_docker_host=`docker inspect --format='{{ index .Config.Labels "com.theimpossiblecode.expose.useDockerName"}}' $cid`
        if [ "$use_docker_host" = "true" ]; then
            host=`docker inspect --format='{{.Name}}' $cid | sed -e 's@^/@@'`
        else
            host=`docker inspect --format='{{ index .Config.Labels "com.theimpossiblecode.expose.host"}}' $cid`
            subdomain_hosts=`docker inspect --format='{{ index .Config.Labels "com.theimpossiblecode.expose.subdomainHosts"}}' $cid`
        fi
        container_domain=`docker inspect --format='{{ index .Config.Labels "com.theimpossiblecode.expose.domain"}}' $cid`
        domain_is_host=`docker inspect --format='{{ index .Config.Labels "com.theimpossiblecode.expose.domainIsHost"}}' $cid`
        if [ "$host" != "" -o "$container_domain" != "" -o "$subdomain_hosts" != "" ]; then
            ips=$(docker exec $cid ip address | perl -ne 'if (/ether/ .. /global/) {print "$1\n" if /(\d+\.\d+\.\d+\.\d+)/}')
            for ip in $ips; do
                # Take the first reachable IP
                $ECHO "Checking IP $ip"
                if ping -c 1 -W 1 $ip ; then
                    $ECHO "$ip is reachable"
                    break
                fi
                $ECHO "$ip is not reachable"
                ip=""
            done
            if [ "$ip" = "" ]; then
                # No reachable IP
                continue
            fi
            $ECHO -n "$ip  " >> $CONTAINER_HOSTS
            if [ "$container_domain" = "" ]; then
                container_domain=$DOMAIN_NAME  
            elif [ "$container_domain" != "$DOMAIN_NAME" ]; then
                if [ "$domain_is_host" = "true" ]; then
                    $ECHO -n "$container_domain " >> $CONTAINER_HOSTS
                fi
            fi
            subdomain_hosts="$host $subdomain_hosts"  
            for host in $subdomain_hosts; do
                $ECHO -n " $host" >> $CONTAINER_HOSTS
                if [ "$container_domain" != "" ]; then
                    $ECHO -n " $host.$container_domain" >> $CONTAINER_HOSTS
                fi
            done
            $ECHO  >> $CONTAINER_HOSTS
        fi
    done

    # Ask dnsmasq to reload
    pkill -x -HUP dnsmasq
}

function set_timer
{
   ( sleep $1
     kill -ALRM $$
   ) &
}

events_raised=0
function timeout_handler
{
    $ECHO "regenerating the $CONTAINER_HOSTS file after $events_raised events"
    generate_docker_hosts
    events_raised=0
}
trap timeout_handler SIGALRM

# Exernal loop to handle docker restarts
while [ 1 ] ; do
    $ECHO "waiting for docker to be up"
    if ! docker network ls > /dev/null 2>&1 ; then
        # Wait for docker networks to start
        while ! docker network ls > /dev/null 2>&1 ; do
            sleep 1
        done
    fi

    $ECHO "register for docker start/stop events"
    # Listen on docker events to maintain the CONTAINER_HOSTS file
    coproc docker events --filter 'event=start' --filter 'event=stop'

    # Initialize the CONTAINER_HOSTS now
    $ECHO "generating an initial $CONTAINER_HOSTS file"
    generate_docker_hosts

    # Internal loop to handle docker events
    while read -u ${COPROC[0]} line; do
        if [ $events_raised != 0 ]; then
            # Just count until the timer expires
            let events_raised++
        else
            # Start counting events and handle them all at once
            #  after WAIT_EVENS_TO seconds
            $ECHO "will generate $CONTAINER_HOSTS in $WAIT_EVENS_TO seconds"
            events_raised=1
            set_timer $WAIT_EVENS_TO
        fi
    done
done
